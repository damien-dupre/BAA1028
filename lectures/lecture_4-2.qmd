---
title: "Lecture 4: Git, GitHub, and Version Control"
subtitle: BAA1028 - Workflow & Data Management 
author: Damien Dupré
format:
  revealjs:
    theme: [theme/metropolis.scss]
    toc-depth: 1
    chalkboard: false
    menu: true
    slide-number: true
title-slide-attributes:
    data-background-iframe: logo-fall/index.html
preload-iframes: true
---

```{r setup, include = FALSE}
# libraries --------------------------------------------------------------------
library(anicon)
library(countdown)
library(fontawesome)
library(knitr)

# functions --------------------------------------------------------------------
include_img <- function(img_name) {
  paste0("https://raw.githubusercontent.com/damien-dupre/img/main/", img_name) |> 
  knitr::include_graphics()
}

browseURL("https://drmowinckels.io/talks_repo/slides/2023.03.28-promenta-fileorg/")
browseURL("https://drmowinckels.io/talks_repo/slides/2022.04.28-git-github/#/title-slide")
browseURL("https://drmowinckels.io/talks_repo/slides/2022.03.03-fileorg/#1")
browseURL("https://drmowinckels.io/talks_repo/slides/2022.02.03-rproj/#1")
browseURL("https://www.ethanrosenthal.com/2024/10/23/portable-quarto-reports/")
```

## Examples of a folder/file path

- MS Windows: Folder path to my former workshop materials
`E:\syncwork\projects\confer\ps2021-10-ws-repro-research`

- Linux (MSYS2): Folder path to my workshop materials
`/E/syncwork/projects/confer/ps2021-10-ws-repro-research`

- Full file path specified in Stata to load a dataset (MS Windows): `use
"J:\Work\PARI\PARI-F\data\pari-f_data_v0-1.dta"`

- Full file path specified in R to load a dataset (MS Windows):
`read.dta("J:/Work/PARI/PARI-F/data/pari-f_data_v0-1.dta")` (confusing? see
below...)

(Note, these are all examples of *absolute path* specifications)

## What is a path?

> "A path to an entity (in this case, a file, folder, or web page) describes the
entity’s unique location within a hierarchical directory or website structure"
(https://www.educative.io/edpresso/absolute-vs-relative-path).

## What is a path?

> "A path is a string of characters used to uniquely identify a location in a
directory structure. It is composed by following the directory tree hierarchy in
which components, separated by a delimiting character, represent each directory.
The **delimiting character** is most commonly the **slash ("/")**, the
**backslash character ("\\")**, or colon (":"), though some operating systems
may use a different delimiter. Paths are used extensively in computer science to
represent the directory/file relationships common in modern operating systems,
[...]. Resources can be represented by either **absolute or relative paths**"
(emphasis mine; https://en.wikipedia.org/wiki/Path_(computing))

## Delimiting characters

<font style="color:red"> THIS IS IMPORTANT !!$!!!"§!111111</font>

- Delimiting characters `/` or `\` vary by operating system

- MS Windows: 

    - Use a colon `:` to specify the drive name (e.g., `c:`, `d:`, `e:`)

    - Folders and files are seperated by a backslash character (`\`)

    - Example: `J:\Work\PARI\PARI-F\data\pari-f_data_v0-1.dta`

## Delimiting characters

- Linux/macOS:

     - No colon (`:`)

     - Use only the slash (`/`) character

     - Example: `/E/syncwork/projects/confer/ps2021-10-ws-repro-research`

     - Another (dynamically created) example showing the (full) path to my
     current working directory (using Python):

```{python}
import pathlib
pathlib.Path().resolve()
```

## Delimiting characters

- Software, such as R, $\LaTeX$, and Python, with a Linux/UNIX background behaves differently under MS Windows when it comes to 
  specifying file/folder paths

- That is, when specifying a path (e.g., in R or $\LaTeX$) in MS Windows, these 
  programs do not like the backslash character (`\`) (the backslash is used for 
  "escaping" other characters)

## Delimiting characters

- Two solutions:
    - Use the slash character `/`, e.g.:   
    ```R
    library(haven)
    read.dta("J:/Work/PARI/PARI-F/data/pari-f_data_v0-1.dta")
    ```
    - Escape the backslash character via `\\`, e.g.:
    ```R
    library(haven)
    read.dta("J:\\Work\\PARI\\PARI-F\\data\\pari-f_data_v0-1.dta")
    ```

- For more information see, e.g., https://www.dummies.com/programming/r/how-to-work-with-files-and-folders-in-r/

## Delimiting characters

- Note: Many programming languages/statistical packages (R, Python, ...) can
dynamically create a full path that follows the rules of the respective
operating system:
    - R: 
    ```R
    file.path("J:", "Work", "PARI", "PARI-F", "data", "pari-f_data_v0-1.dta")
    [1] "J:/Work/PARI/PARI-F/data/pari-f_data_v0-1.dta"
    ```
    
    - Python: 
    ```python
    import os
    os.path.join("e:", "folder1", "folder2", "file")
    ```
    returns: `'e:folder1\\folder2\\file'` (in Windows)

## Delimiting characters
    
- Stata, actually, does not care... 
  - `use "J:\Work\PARI\PARI-F\data\pari-f_data_v0-1.dta"`
  - `use "J:/Work/PARI/PARI-F/data/pari-f_data_v0-1.dta"`

- Johannes suggests a handy tool when working on both operating system: [Path
Copy Copy -- Copy file paths from Windows explorer's contextual
menu](https://pathcopycopy.github.io/)

## Absolute and relative paths

- There exist two types of paths: absolute or relative paths

- Example of an absolute path (in MS Windows):
`J:\Work\PARI\PARI-F\data\pari-f_data_v0-1.dta`

- Example of a relative path (in MS Windows): `..\data\pari-f_data_v0-1.dta`

.small[(Source: https://www.earthdatascience.org/courses/intro-to-earth-data-science/python-code-fundamentals/work-with-files-directories-paths-in-python/)]

## Absolute paths (or full path)

- Contains the entire path to the file or directory that you need to access 

- It will begin at you computer's root directory (or respective Window's drive)
and will end with the file or directory that you wish to access

- E.g., in MS Windows: `J:\Work\PARI\PARI-F\data\pari-f_data_v0-1.dta` or
`D:\tmp\yipiyy.txt` 

# ```{r, out.width = "70%", echo = F}
# woRkshoptools::include_picture("./f_explorer-full-path.png")
# ```

## Absolute paths (or full path)

- In Linux or macOS: `/home/weiss/important/yipiyy.txt` 

- **Avoid using absolute paths as much as possible since it reduces the
portability of your project (your colleague's computer, someone who wants to
reproduce your analyses)**

## Working directory and relative paths

- A relative path is relative to a "fixed location" on your computer

- Often, this "fixed location" is the so-called "working directory" 

- So, when starting your data analysis, you first define your "working
directory" as absolute path -- **this is done just once!**

## Working directory and relative paths

- All other file- or folder-related operations are defined relative to this
working directory

- **The huge benefit: when you share your project with a colleague or move it to
a new computer, you only have to define the working directory once, everything
else should work flawelessly**

- How to define a working directory?

    - R: `setwd("full-path-to-working-directory")` 
    
    - Stata: `cd "full-path-to-working-directory"` (`cd` = change directory)

    - Python: `import os; os.chdir("full-path-to-working-directory")`

- .small[(Note: in R you can also use the `here` package; RStudio users are
refered to RStudio projects, for more information see [Why should I use the here
package when I'm already using
projects?](https://malco.io/2018/11/05/why-should-i-use-the-here-package-when-i-m-already-using-projects/))]

## Working directory and relative paths

- How to get information about the current working directory?
    - R: `getwd()` 
    ```r
    > getwd()
    [1] "D:/Eigene Dateien/Dokumente"
    ```
    - Stata: `cd`
    ```stata
    .cd
    C:\Program Files\Stata15
    ``` 
    - Python: `import os; os.getcwd()` (cwd = current working directory); see below for an example
    ```python
    import os 
    os.getcwd()
    ```
    
## Working directory and relative paths

- So, let's assume the project "PARI-F" is located on drive `J:`, the full
absolute path is `J:\Work\PARI\PARI-F`

- The content of the project's folder `PARI-F` is:
```
.
|-- analysis
|-- data
|-- doc
|-- pari-f.stpr
`-- report
```
- Loading a dataset located in folder `data`, can be accomplished as follows:
    - In R:
    ```r
    library(haven); library(ggplot2)
    setwd("J:/Work/PARI/PARI-F")          # Define working directory just once.
    read.dta("data/pari-f_data_v0-5.dta") # Absolute path: J:/Work/PARI/PARI-F/data/pari-f_data_v0-5.dta
    ...
    ggplot(...)
    ggsave("doc/my-fancy-plot.pdf")       # Will be saved in J:/Work/PARI/PARI-F/doc/my-fancy-plot.pdf
    ```

## Shortcuts (`.` and `..`) 

.small[See also https://en.wikipedia.org/wiki/Path_(computing)]

- The dot `.` denotes the current working directory
- The dot dot `..` denotes the parent directory, i.e., it points upwards in the
folder hierarchy
- Example in R
     ```r
    library(haven); library(ggplot2)
    setwd("J:/Work/PARI/PARI-F/data")  # Define working directory just once, now we are in /data.
    read.dta("pari-f_data_v0-5.dta")   # Absolute path: J:/Work/PARI/PARI-F/data/pari-f_data_v0-5.dta
    ## more code...
    ## plot something
    ggsave("../doc/my-fancy-plot.pdf") # Read: 
                                       # - We are in J:/Work/PARI/PARI-F/data
                                       # - The plot should be saved to J:/Work/PARI/PARI-F/doc
                                       # - ".." = go to parent folder of data, i.e., J:/Work/PARI/PARI-F
                                       # - Then, go to folder /doc and store the plot in this folder 
    ```
- Finally, the tilde symbol `~` will bring you back to your home directory, e.g. `cd ~`


# Using a comand-line interface (CLI)

## MS Window's default comand-line interpreter (`cmd.exe`)

```{r, out.width = "75%", echo = F}
woRkshoptools::include_picture("./f_cli-cmd.png")
```

## Windows PowerShell 

```{r, out.width = "75%", echo = F}
woRkshoptools::include_picture("./f_cli-powershell.png")
```

## The Bash shell (Linux, macOS, MS Windows, ...)

```{r, out.width = "75%", echo = F}
woRkshoptools::include_picture("./f_cli-shell.png")
```

## What is a command-line interface (CLI)? 

> "A command-line interface (CLI) **processes commands** to a computer program
in the form of **lines of text**. The program which handles the interface is
called a command-line interpreter or command-line processor. Operating systems
implement a command-line interface in a shell for interactive access to
operating system functions or services. Such access was primarily provided to
users by computer terminals starting in the mid-1960s, and continued to be used
throughout the 1970s and 1980s on VAX/VMS, Unix systems and personal computer
systems including DOS, CP/M and Apple DOS."

(emphasis mine; https://en.wikipedia.org/wiki/Command-line_interface)

## And what is a shell?

> "In computing, a shell is a computer program which exposes an operating
system's services to a human user or other program. In general, operating system
shells use either a command-line interface (CLI) or graphical user interface
(GUI), depending on a computer's role and particular operation. It is named a
shell because it is the outermost layer around the operating system."

(https://en.wikipedia.org/wiki/Shell_(computing))

## Okay, but why?!

- Fast and effcient way to interact with your computer

- Important part of your automation toolbox to create a reproducible data
analysis pipeline

- "1-Click Reproducibility" or better (but less catchy): "1-Command-on-a-CLI
Reproducibility"

- Many functions that RStudio provides are actually based on command-line tools
(Git, pandoc, $\LaTeX$, ...) -- it might be helpful to understand what is
happening under the hood

## Okay, but why?!

- Accessing a remote server almost always requires some sort of command line
skills

- ...

(Source: [Piccolo, 2016](https://gigascience.biomedcentral.com/articles/10.1186/s13742-016-0135-4))

.small[I also recommend "Top ten reasons to learn to use the command line:
Expanding your reproducibility tools", see
https://riffomonas.org/code_club/2020-08-17-command-line-life]

<!-- ## If the only tool you have is a sledgehammer... -->

<!-- > "When I fire up my Terminal app people that don’t know me well often look on in disgust, no doubt asking themselves what century I was born in. Surely they think, this is 2020! We have touch screens! Beautiful web apps! Amazing software with graphical interfaces! Yup. They’re fun. **But, if your goal is to conduct a reproducible analysis, then you need to step away from those tools and dig into the command line.** Another reaction is, don’t you know about this great R package to do that? I love R! But it’s not always the right tool for the job. Sometimes using R is like using a sledgehammer to pound in a nail or worse, sometimes it’s like using a sledgehammer to pound in a screw. I could, but why? Doing the same thing at the command line with bash commands would be so much easier." (emphasis mine; https://riffomonas.org/code_club/2020-08-17-command-line-life) -->

<!-- --- -->

## The Git Bash

- My CLI of choice is [the Bash](https://www.gnu.org/software/bash/)

- Linux/macOS user already have access to the Bash

- MS Windows user can use the "Git Bash" 

```{r, out.width = "75%", echo = F}
woRkshoptools::include_picture("./f_git-bash.png")
```

## Important commands

- Note, some of these commands depend on the respective operating system

- Almost all of these command can have several arguments, e.g., `ls -la`

- Linux cheatsheet: https://files.fosswire.com/2007/08/fwunixref.pdf

- MS Windows cheatsheet: http://www.cs.columbia.edu/~sedwards/classes/2015/1102-fall/Command%20Prompt%20Cheatsheet.pdf

## Important commands

| Description | Win | Linux, macOS (Bash) |
| :--- | :--- | :--- |    
| Copy files, folders | `copy` | `cp` |
| Move files, folders | `move` | `mv` |
| List folder content | `dir` | `ls` |
| Create new folder | `mkdir` | `mkdir`|
| Change current folder | `cd` | `cd` |
|Show current path| `echo %cd%` | `pwd`|
| **Danger zone** No undo!|
| Delete file(s) | `del` | `rm` |
| Delete folder(s) | `rmdir`| `rm`|

## A small script to create a project folder

The following small bash/shell script was
introduced in the very beginning of this module. It initializes a new project
folder. It even detects when you forget to submit a folder name for your
project (can be found here: `\content\sh\`):

```
#!/bin/sh

# Yes, I had to google that... 
# https://stackoverflow.com/questions/6482377/check-existence-of-input-argument-in-a-bash-shell-script
if [ $# -eq 0 ]
  then
    echo "No arguments supplied! You stupid!!!!!!"
    exit 1
fi

mkdir $1
cd $1
mkdir data
mkdir src
mkdir output
touch .gitignore
touch README 
```

## Exercise

- Start the Git Bash

- List the content of the current folder via `ls -la`

- Determine where you are via `pwd`

- Go to the parent folder via `cd <your input>`

- Copy the content from my small script (see above, section [](cli:create-project), use the little copy-icon in the top-right corner) and past it into a text file, save the text file as `create-project.sh`

- Execute the script `./create-project.sh` (the `./` is important, for an explanation see [here](https://stackoverflow.com/questions/6331075/why-do-you-need-dot-slash-before-executable-or-script-name-to-run-it-in-bas)) without a folder name

- Execute the script `./create-project.sh <your-new-project>` with a folder name as argument

# The power of plain text

## It is 2022, why plain text?

- Version control (e.g., Git) works well (efficient, differences between
versions are easy to understand) with plain text documents, `.docx` et al. not
so much

- Future proof 

- Can easily manipulated with external tools

- ...

.small[Canonical reference: [The Plain Person’s Guide to Plain Text Social
Science](https://plain-text.co/) by Kieran Healy]

## Encoding

- Puh, what is [(character) encoding](https://en.wikipedia.org/wiki/Character_encoding)?

- See also https://www.w3.org/International/questions/qa-what-is-encoding.en

- My only rule: Use utf-8

- If you run into trouble, use a search engine your trust... which will most likely lead to a Stackoverflow page

- Example: [How to keep umlaut in R?](https://stackoverflow.com/questions/61490124/how-to-keep-umlaut-in-r)

## Encoding

- Notepad++ is my my tool of choice...

- On the command line (Linux/Bash), you can use the command `file`, see below for the encoding of my references file:

```
file references.bib
```
    references.bib: Unicode text, UTF-8 text, with very long lines (1869)
    
# Git

## What is Git ?

It's a version control system, which works like a time machine. In this time machine, it has check points which is known as 
Commits and it's unique for every check point. It has a super cool feature like multiverse aka Branching, that lets us create
an alternate version of our code. A branch is a copy of project and it's super useful when working in groups, allowing us the 
capability of working on with or without changing the original code. We can also synchronize the changes that happened across different
branches and that's called Merging.

### Setting up Git

1. The first step is to set up some configuration variables which helps git to keep track of contributor and contributors contribution.
To set up the basic changes we will run `git config` command.

```bash
# git config command
git config --global user.name "Your Name"
git config --gloabl user.email "Your Email"
```

The global option makes sure that every project in that local machine will use that name and email address.
To see all the global configuration we can run the below command:

```bash
# displaying git global configuration command
git config --list
```

To see where the settings file are defined, we can run bellow command:

```bash
# displaying setting files location command
git config --list --show-origin
```

2. Once we set up the global variables, we will initialize the project. To do so, we have to go to that directory from the command line.

```bash
# changing directory command
cd folder/location
```

Once we are in the desired directory, we will initialize our project using `git init` command

```bash
# initializing git command
git init
```

It will create a .git file in the same directory and by default it's hidden. To see that, we need to type `ls -la` command on terminal.
`git init` command initialize the project for us and make files that are necessary for keeping track of our changes. We can change the 
directory to see what files have been created by the `git init` command.

```bash
cd .git
ls -la
```

It will display that git has created a several files to keep the tracks of our changes. 

In VS Code, `git init` command will change the color of the files and it will show `U` beside the file names. `U` means **Untracked File**

3. After initializing the git, we need to add the files in the staging environment with `git add` command. Staging is a temporary area
that we can store files that we want to commit later.

```bash
# basic command for adding Files
git add FILENAME # it adds single file at a time and it's a good practices
# Alternative Options
git add --all # it adds all the file in the directory to the staging environment
git add -A # does the same thing as --all but it's a shortcut
git add . # same as --all and -A
```

after executing the `git add` command it  will change that file from `U` to `A` in the VS Code. `A` means Added.

4. Last step is to commit the changes using the `git commit` command. 

```bash
# basic commit command
git commit -m "Commit Message"
# commit command with description along with commit Message
git commit -m "Commit Message" -m "Commit Description"
```

git commit message should be short and precise. What are the changes being made, why are the changes and the functionalities it will add.
git commit message should be like email subject. 

`git commit` command will remove the `A` tag beside the files names in VS Code. It means these files has been committed into your local machine.
Any changes made after this will flag the file as `M` tag. `M` means Modified. 

To verify git is keeping the track of our work we can use `git log` command.

```bash
# verifying command to check if git is keeping track 
git log
```

It will show the entries that has been made in the .git folder. It shows the commit hash, author name, date with timestamp, and commit message.


#### Workflow of git

```{mermaid}
flowchart TD
  A[Initializing git] --> B[Adding files in the staging environment]
  B --> C[Committing the files]
  C --> D[Push the files in the remote repo]
```


### Understanding Git Environments

#### Git information

`git log` command shows us some information about the commits that has been made. I will use the output of our first commit.

```bash
git log
# Below is the output
commit 1b12ec3c6bc7dfc48fa33c3ae655564a02700162 (HEAD -> main) # commit hash, which is unique for every commit
Author: Shuvo Barman <user@users.noreply.github.com> # Name of the author and email
Date:   Sun Dec 17 16:32:29 2023 -0330 # detailed time of the commit

    Initial commit # commit message
```
the HEAD always point to the current branch in this case it's `main`

#### Git Environments

Git has 3 stages where we can move files.

```{mermaid}
flowchart TD
  A[Git] --> B[Working]
  A --> C[Staging]
  A --> D[Commit]
```

1. Working: Here the files looks like what they did during the last commit.
2. Staging: Before we create a new commit, we can move our file to a temporary location called Staging. It gives us a queue up changes
until we are ready to commit.
3. Commit: This is the final environment. In this stage, a new log entry is created with a new hash.

Before a commit a file can be in one of two main states.


```{mermaid}
flowchart TD
  A[File States] --> B[Tracked]
  A --> C[Untracked]
```

1. Tracked Files: These are the files that existed in the previous snapshot (another name for commit).
2. Untracked Files: Untracked files are anything else.

Tracked files can be in different states

```{mermaid}
flowchart TD
  A[Tracked Files] --> B[Unmodified]
  A --> C[Modified]
  A --> D[Staged]
```

1. Unmodified: Files haven't changed since the last commit.
2. Modified: Files have changed since the last commit.
3. Staged: Files that have been moved to staging environment.

We can see this with `git status` viewing command.

```bash
# Viewing status command
git status
```

If a file goes into Modified Stage, we have two option for that file. One is adding that file using `git add` command
or we can restore it using `git restore` command.

```bash
# restoring file command
git restore FILENAME
# Alternative options
git restore . # restore all the files into it's previous state
git checkout . # older version of restore command
```

### Ignoring Files

Even if git is used to keep track of files but sometimes we don't want to keep track of all the files.
There could be several reasons behind it. Such as:
- Sensitive information(i.e. Password, Authentication tokens, API keys etc.)
- Personal notes(i.e. To-Do list for project)
- System files
- Large files

we can achieve this by creating a new file called `.gitignore`. Inside this file we can add any types of pattern, file name, folder name etc.
which will git ignore. Git doesn't track empty folders.

we can also use global ignore file to ignoring files or pattern that we don't want git to upload.

```bash
# global git ignore command
git config --global core.excludesfile [file]
```

Clearing the cahce using below command.

```bash
# cache clearing command
git rm -r --cached .
```

### Deleting 

It can be done in two ways, from command line and another is doing manually from the IDE interface. we use `git rm` command to delete file.

```bash
# delete file command
git rm FILENAME
# force fully delete file 
git rm -f FILENAME
```

If we delete the file using `git rm` command, it deletes the file and moved that deletion automatically into staging. But if we do it manually from 
IDE interface we have do move that file from staging. 

After deleting a certain file using `git rm` command, if we want to restore the file we need to execute below command

```bash
# restoring deleted file command
git restore --staged FILENAME
# git restore -S FILENAME
```

after executing the above command we have to execute below command as well.

```bash
git restore FILENAME
```

### Renaming

This is a tricky part if we do it from the IDE interface manually. It will track two action: first deletion of certain file and 
second creating a new file. if we want to restore the manually renamed file using `git restore` command, git will keep both the 
files.

To do it from the command line we have to use `git mv` command

```bash
# file renaming command
git mv OLD_FILE_NAME NEW_FILE_NAME
```

To restore the renamed file to it's previous name, we can use the same command `git mv` with just changing the order of file names.

### Git difference

we use `git diff` command to see the changes we made accross the files. If we made changes to a handful number of files then it's 
easier to use the IDE interface.

```bash
# checking difference command
git diff
```

We can also compare files based on commit hash. 

```bash
git diff COMMITHASH
```

We use `git log` to check the git history but if we don't want to see all the information, we can use `git log --oneline` command

```bash
git log --oneline
```

It will show the commit hash and commit message as decending order. We can also the git commits as a graph, which makes it really helpful
when we have multiple branches.

```bash
# git log as graph 
git log --all --decorate --oneline --graph 
# or
git log --oneline --all --graph
```

### Changing History

#### Using Git Amend

As we know git keeps track of all our changes, sometimes we end up with some commits that was not right. We can do another commit 
with proper changes but that will make the git history quiet messy. We can use `git amend` command to add changed files to the last
commit.

```bash
# changing history command
git commit --amend
# Alternative options
git commit --amend -m "New Commit Message"
git commit --amend --no-edit
```

`git amend` command will launch the default editor and allow us to edit the file with the amended history. We can avoid that by using the second line
if we want to have a different commit message, it will change the commit message directly in the command line. We can also keep the commit message same
as the last commit by executing the third command.


#### Using Git Reset

We can also do that, using `git reset` command. Resetting let us go back to a previous commit, and we have to give that commit hash in the command.

```bash
# resetting command
git reset COMMIT_HASH
```

This will go back to that commit hash snapshot and point the head to that. But it will not delete the changes that we made in the files.
It will show those files as modified after getting back to that particular commit. If we want to discard all the changes we can use the
`git reset --hard` command, it will discard all the changes after that commit hash. But be careful as it's going to delete all the changes
along with commits.

```bash
# hard reset command
git reset --hard COMMIT_HASH
```

#### Using Git Rebase

Rebasing is another way of changing history and it's designed to take the commits from one branch and apply them to another.

```bash
# git rebasing command
git rebase <branch>/<commit>
# Alternative options
git rebase --interactive <branch>/<commit> # best way to use rebase
git rebase -i HEAD~# # useful when have a long commit history and only want to go back to certain steps
git rebase -i --root # bring all the history in ascending order and let us pick
```

### Branches

to see the brances we can use `git branch` command. It will show all the available branc in our project.

```bash
# checking git branch command
git branch
```

To create a new branch we will have to take a copy of a snapshot from another branch and start working from there. To do so, 

```bash
# copying a branch command
git switch -c NAME
# Alternative Option
git checkout -b NAME # older version of git switch
```

`git merge` command will merge the changes from one branch into the current branch.

```bash
# merge command syntax
git merge <branch>
```

When we merge a feature into main branch, it's a good idea to delete that branch. To do that, we use below command

```bash
# git branch delete command syntax
git branch --delete NAME
# Alternative Option
git branch -d NAME # we can use this as long as branches have no conflicts
git branch -D NAME # ignore any conflicts, forcefully delete the branch
```

These sequence of doing things is also called git flow.

#### Git flow

- Feature / Fix branch
- Make changes
- Merge changes to main branch
- Delete the feature / fix branch


### Merge Conflicts

Conflicts happen when we try to merge two branches, but there are changes made in the file. 

###  Git Stash

Stashing is a way of putting away code temporarily. We can do that via `git stash` command.

```bash
# stashing command syntax
git stash
# Checking git stash command
git stash list # for checking what has been stored
git stash apply # apply a set of changes from stash
git stash pop # remove the git stash from the list
```

It's can be think of as a deck of cards, we can stash on top of another stash.

### Git Clean

remove all untracked files and directories from your branch super quicky. Nice way of removing files that we don't need anymore.

```bash
# git clean command syntax
git clean -n # dry run
git clean -d # directories
git clean -f # force
```

We can combine these commands together as well, i.e. `git clean -dn` to remove both untracked file and directories


# Description of files in GitHub repo

It's good practice to include some files in our github repo which will help people understand a bit more about our 
project. It makes the project self explanatory and well documented.

- **README.md:**
It tells about the purpose of the project, which is essentially describing what the project does and why it's useful.
It also works as a homepage for the repo. It can provide table of contents, dependencies for the project, installation
guidelines and so on.

- **LICENCE:**
Public repositories are normally used to share open source software, but we need to define how developers can use,
change or distribute the software. For doing so, we need a **LICENCE** file and the location of the file is in the 
root folder.

- **CODE_OF_CONDUCT.md:** 
This file establishes the expectations as to how people are supposed to behave when using your public repo or open
source software.

- **SECURITY.md:**
This file specify the security support and where to report vulnerabilities.

- **CONTRIBUTING.md:**
This file defines the guidelines for other developers on how they can contribute to the project.

- **SUPPORT.md:**
This file defines the rules on regulations about how other people can get support for the open source project.

- **CODEOWNERS:** 
This is a simple text file where describes the list of persons who are responsible for maintaining the 
repo up to date and who changes the code. The format for this file is pretty similar to `.gitignore` file.

## References

Huge thanks the following people who have generated and shared most of the content of this lecture:

- Bernd Weiß: [Tools and Workflows for Reproducible Research in the Quantitative Social Sciences - Computer Literacy](https://jobreu.github.io/reproducible-research-gesis-2022/slides/comp-literacy.html#1)

<br>

```{r}
#| fig-align: "center"
knitr::include_graphics("https://media2.giphy.com/media/v1.Y2lkPTc5MGI3NjExdGdyMnhseGczY3NheHU1cHhtdGRzdWRxaXJ1Z3BsdWF6MWdwZm84ZyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/3ohs7JG6cq7EWesFcQ/giphy.gif")
```
